<!DOCTYPE html>
<html lang="pt-BR"><head>
<meta charset="UTF-8" />
<title>Jogo 2 Players 3D</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  #info {
    position: absolute; top: 10px; left: 10px; color: white; font-family: monospace; z-index: 10;
  }
</style>
</head>
<body>
<div id="info">
  <div>Player 1: WASD + Espaço (tiro)</div>
  <div>Player 2: Setas + Enter (tiro)</div>
  <div>Vidas P1: <span id="p1lives">3</span> | Vidas P2: <span id="p2lives">3</span></div>
  <div>Fase: <span id="level">1</span></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 20);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // Luz
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 20, 10);
  light.castShadow = true;
  light.shadow.mapSize.width = 1024;
  light.shadow.mapSize.height = 1024;
  light.shadow.camera.near = 1;
  light.shadow.camera.far = 50;
  light.shadow.camera.left = -20;
  light.shadow.camera.right = 20;
  light.shadow.camera.top = 20;
  light.shadow.camera.bottom = -20;
  scene.add(light);

  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);

  // Chão
  const floorGeometry = new THREE.PlaneGeometry(50, 50);
  const floorMaterial = new THREE.ShadowMaterial({opacity: 0.4});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Variáveis do jogo
  let level = 1;
  let monsters = [];
  let bullets = [];
  let monsterBullets = [];

  // Player class
  class Player {
    constructor(color, startX, controls) {
      this.lives = 3;
      this.speed = 0.15;
      this.size = 1;
      this.direction = new THREE.Vector3(1, 0, 0); // inicial pra direita
      this.controls = controls;
      this.shooting = false;
      this.shootHoldTime = 0;
      this.canShoot = true;
      this.lastShotTime = 0;

      // Criar mesh
      const geometry = new THREE.BoxGeometry(this.size, this.size*2, this.size);
      const material = new THREE.MeshStandardMaterial({color, roughness:0.7});
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.castShadow = true;
      this.mesh.position.set(startX, this.size, 0);
      scene.add(this.mesh);
    }

    move(keys) {
      let moved = false;
      const dir = new THREE.Vector3();

      if (keys[this.controls.left]) {
        this.mesh.position.x -= this.speed;
        dir.set(-1, 0, 0);
        moved = true;
      }
      if (keys[this.controls.right]) {
        this.mesh.position.x += this.speed;
        dir.set(1, 0, 0);
        moved = true;
      }
      if (keys[this.controls.up]) {
        this.mesh.position.z -= this.speed;
        dir.set(0, 0, -1);
        moved = true;
      }
      if (keys[this.controls.down]) {
        this.mesh.position.z += this.speed;
        dir.set(0, 0, 1);
        moved = true;
      }
      if (moved) {
        this.direction.copy(dir);
      }
    }

    update(delta, keys, time) {
      this.move(keys);

      // Atirar
      if (keys[this.controls.shoot]) {
        this.shootHoldTime += delta;
        if (this.shootHoldTime >= 10) {
          // tiro automático 500 tiros por segundo
          if (time - this.lastShotTime > 1/500) {
            this.shoot();
            this.lastShotTime = time;
          }
        } else if (this.canShoot) {
          this.shoot();
          this.canShoot = false;
          setTimeout(() => { this.canShoot = true }, 300); // delay de 0.3s pra tiros normais
        }
      } else {
        this.shootHoldTime = 0;
        this.canShoot = true;
      }
    }

    shoot() {
      const b = new Bullet(this.mesh.position.clone(), this.direction.clone(), this);
      bullets.push(b);
    }

    loseLife() {
      this.lives--;
      updateLives();
      if (this.lives <= 0) {
        // remove do jogo
        scene.remove(this.mesh);
        players = players.filter(p => p !== this);
      }
    }
  }

  // Bullet class
  class Bullet {
    constructor(position, direction, owner) {
      this.speed = 1;
      this.position = position.clone();
      this.direction = direction.clone().normalize();
      this.owner = owner;
      this.size = 0.3;

      const geometry = new THREE.SphereGeometry(this.size, 8, 8);
      const material = new THREE.MeshStandardMaterial({color: owner === players[0] ? 0x00ff00 : 0x0000ff});
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.castShadow = true;
      this.mesh.position.copy(this.position);
      scene.add(this.mesh);
    }

    update() {
      this.position.addScaledVector(this.direction, this.speed);
      this.mesh.position.copy(this.position);
    }

    remove() {
      scene.remove(this.mesh);
    }
  }

  // Monster class
  class Monster {
    constructor(health) {
      this.health = health;
      this.speed = 0.05;
      this.size = 1.5;

      const geometry = new THREE.ConeGeometry(this.size / 2, this.size * 2, 8);
      const material = new THREE.MeshStandardMaterial({color: 0xff0000, roughness: 0.8});
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.castShadow = true;

      // spawn aleatório dentro do campo
      const spawnRange = 20;
      this.mesh.position.set(
        (Math.random() - 0.5) * spawnRange,
        this.size,
        (Math.random() - 0.5) * spawnRange
      );
      scene.add(this.mesh);
    }

    update() {
      if (players.length === 0) return;

      // Seguir jogador mais próximo
      let target = players[0];
      let minDist = this.mesh.position.distanceTo(target.mesh.position);

      for (let p of players) {
        const dist = this.mesh.position.distanceTo(p.mesh.position);
        if (dist < minDist) {
          target = p;
          minDist = dist;
        }
      }

      // Direção para o alvo
      const dir = target.mesh.position.clone().sub(this.mesh.position).normalize();
      this.mesh.position.addScaledVector(dir, this.speed);

      // Colisão com player (simples distância)
      if (this.mesh.position.distanceTo(target.mesh.position) < this.size) {
        target.loseLife();
        this.health = 0; // morre após atacar
      }
    }

    takeDamage() {
      this.health--;
      if (this.health <= 0) {
        this.die();
      }
    }

    die() {
      scene.remove(this.mesh);
      monsters = monsters.filter(m => m !== this);
    }
  }

  // Funções auxiliares
  function updateLives() {
    document.getElementById('p1lives').innerText = players[0] ? players[0].lives : 0;
    document.getElementById('p2lives').innerText = players[1] ? players[1].lives : 0;
  }
  function updateLevel() {
    document.getElementById('level').innerText = level;
  }

  // Controle teclado
  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === "Enter") keys["enter"] = true;
    if (e.key === "ArrowLeft") keys["arrowleft"] = true;
    if (e.key === "ArrowRight") keys["arrowright"] = true;
    if (e.key === "ArrowUp") keys["arrowup"] = true;
    if (e.key === "ArrowDown") keys["arrowdown"] = true;
    if (e.key === " ") keys["space"] = true;
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
    if (e.key === "Enter") keys["enter"] = false;
    if (e.key === "ArrowLeft") keys["arrowleft"] = false;
    if (e.key === "ArrowRight") keys["arrowright"] = false;
    if (e.key === "ArrowUp") keys["arrowup"] = false;
    if (e.key === "ArrowDown") keys["arrowdown"] = false;
    if (e.key === " ") keys["space"] = false;
  });

  // Criar jogadores
  let players = [
    new Player(0x00ff00, -5, {up:'w', down:'s', left:'a', right:'d', shoot:'space'}),
    new Player(0x0000ff, 5, {up:'arrowup', down:'arrowdown', left:'arrowleft', right:'arrowright', shoot:'enter'}),
  ];
  updateLives();
  updateLevel();

  // Spawna monstros da fase atual
  function spawnMonsters(level) {
    const baseCount = 1;
    const baseHealth = 1;

    const count = Math.floor(baseCount * Math.pow(1.5, level - 1));
    const health = Math.ceil(baseHealth * Math.pow(1.5, level - 1));

    for (let i=0; i<count; i++) {
      monsters.push(new Monster(health));
    }
  }
  spawnMonsters(level);

  // Loop principal
  let lastTime = 0;
  function animate(time=0) {
    const delta = (time - lastTime) / 1000;
    lastTime = time;

    players.forEach(p => p.update(delta, keys, time/1000));
    bullets.forEach(b => b.update());
    monsters.forEach(m => m.update());

    // Checar colisões: bullets x monsters
    bullets.forEach((b, i) => {
      for (let m of monsters) {
        const dist = b.position.distanceTo(m.mesh.position);
        if (dist < m.size) {
          m.takeDamage();
          b.remove();
          bullets.splice(i, 1);
          break;
        }
      }
    });

    // Remover bullets que saíram do mapa
    bullets = bullets.filter(b => {
      if (Math.abs(b.position.x) > 30 || Math.abs(b.position.z) > 30) {
        b.remove();
        return false;
      }
      return true;
    });

    // Verifica se fase acabou
    if (monsters.length === 0) {
      level++;
      updateLevel();
      spawnMonsters(level);
    }

    renderer.render(scene, camera);

    // Game Over check
    if (players.length > 0) {
      requestAnimationFrame(animate);
    } else {
      alert('Game Over! Todos os jogadores morreram.');
    }
  }
  animate();

  // Ajusta tamanho
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>
</body>
</html>
